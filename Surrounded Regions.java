public class Solution {    static final char C_O = 'O';    static final char C_X = 'X';    static final char C_Z = 'Z';    public void solve(char[][] board) {        int m = board.length;        if (m == 0) {            return;        }        int n = board[0].length;        Node[][] nodes = new Node[m][n];        Stack<Node> stack = new Stack<Node>();        for (int i = 0; i < m; i++) {            for (int j = 0; j < n; j++) {                nodes[i][j] = new Node(i, j);                if (i == 0 || j == 0 || i == m - 1 || j == n - 1) {                    if (board[i][j] == C_O) {                        stack.push(nodes[i][j]);                    }                }            }        }        int ni, nj;        Node node;        while (!stack.isEmpty()) {            node = stack.pop();            board[node.x][node.y] = C_Z;            for (int[] dir : DIRECTIONS) {                ni = node.x + dir[0];                nj = node.y + dir[1];                if (isValid(ni, nj, m, n) && board[ni][nj] == C_O) {                    stack.push(nodes[ni][nj]);                }            }        }        fillChar(board, C_O, C_X);        fillChar(board, C_Z, C_O);    }    class Node {        int x;        int y;        public Node(int x, int y) {            this.x = x;            this.y = y;        }    }    static int[][] DIRECTIONS = new int[][] { { 1, 0 }, { 0, 1 }, { -1, 0 },            { 0, -1 } };    private boolean isValid(int x, int y, int m, int n) {        return x >= 0 && x < m && y >= 0 && y < n;    }    private void fillChar(char[][] board, char findChar, char fillChar) {        int m = board.length;        int n = board[0].length;        for (int i = 0; i < m; i++) {            for (int j = 0; j < n; j++) {                if (board[i][j] == findChar)                    board[i][j] = fillChar;            }        }    }}